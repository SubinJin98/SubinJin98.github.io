---
layout: post
title:  "2776번:: 암기왕"
excerpt: "백준 2776번:: 암기왕 (이분 탐색)"
date:   2023-08-02 16:45:30 +0900
categories:
    - codingtest
tags:
    - Baekjoon
    - BinarySearch

---

## 문제
---
<https://www.acmicpc.net/problem/2776>

연종이는 엄청난 기억력을 가지고 있다. 그래서 하루 동안 본 정수들을 모두 기억 할 수 있다.  
하지만 이를 믿을 수 없는 동규는 그의 기억력을 시험해 보기로 한다. 동규는 연종을 따라 다니며, 연종이 하루 동안 본 정수들을 모두 ‘수첩1’에 적어 놓았다.  
그것을 바탕으로 그가 진짜 암기왕인지 알아보기 위해, 동규는 연종에게 M개의 질문을 던졌다. 질문의 내용은 “X라는 정수를 오늘 본 적이 있는가?” 이다.  
연종은 막힘없이 모두 대답을 했고, 동규는 연종이 봤다고 주장하는 수 들을 ‘수첩2’에 적어 두었다.  
집에 돌아온 동규는 답이 맞는지 확인하려 하지만, 연종을 따라다니느라 너무 힘들어서 여러분에게 도움을 요청했다.  
동규를 도와주기 위해 ‘수첩2’에 적혀있는 순서대로, 각각의 수에 대하여, ‘수첩1’에 있으면 1을, 없으면 0을 출력하는 프로그램을 작성해보자.

## 입력
---
첫째 줄에 테스트케이스의 개수 T가 들어온다. 다음 줄에는 ‘수첩 1’에 적어 놓은 정수의 개수 N(1 ≤ N ≤ 1,000,000)이 입력으로 들어온다.  
그 다음 줄에  ‘수첩 1’에 적혀 있는 정수들이 N개 들어온다.  
그 다음 줄에는 ‘수첩 2’에 적어 놓은 정수의 개수 M(1 ≤ M ≤ 1,000,000) 이 주어지고, 다음 줄에 ‘수첩 2’에 적어 놓은 정수들이 입력으로 M개 들어온다.  
모든 정수들의 범위는 int 로 한다.

## 출력
---
‘수첩2’에 적혀있는 M개의 숫자 순서대로, ‘수첩1’에 있으면 1을, 없으면 0을 출력한다.

## 풀이
---
```python
t = int(input())                          # 테스트 케이스 횟수

for _ in range(t):                        # 위의 횟수대로 반복 수행
    n_cnt = int(input())                  # 수첩1에 적힌 정수 갯수
    n = list(map(int, input().split()))   # 수첩1의 정수를 리스트 형태로 가져옴. 후략
    m_cnt = int(input())
    m = list(map(int, input().split()))

    n.sort()                              # 수첩1 배열 정렬

    # Binary Search Algorithm
    def chk_being(lst, target):           # 리스트와 타겟 값을 인자로 받음
        start, end = 0, len(lst)-1        # start : 리스트의 첫 값, end : 리스트의 마지막 값
        while start <= end:               # 작은 쪽이 큰 쪽보다 커지는 것을 막고, 리스트 내 요소에 대해 T/F 반복 검증
            mid = (start+end) // 2        # 중간값 계산. float 형태 변환을 막기 위해 몫만 취함
            if lst[mid] == target:        # 중간값이 타겟 값과 같을 경우
                return 1                  # 1(=True) 리턴
            elif lst[mid] < target:       # 중간값이 타겟 값보다 작을 경우
                start = mid + 1           # 기존 중간값보다 작은 index는 탐색할 필요 없음
            elif lst[mid] > target:       # 중간값이 타겟 값보다 클 경우
                end = mid - 1             # 기존 중간값보다 큰 index는 탐색할 필요 없음
        return 0                          # 타겟 값과 일치하는 요소가 리스트 내에 없을 경우 0(=False) 리턴

    for i in range(m_cnt):                # 수첩2에 적힌 정수 갯수만큼 반복
        if chk_being(n, m[i]):            # 타겟 값 : 수첩2의 i번째 값, 리스트 : 수첩1의 전체 값(정렬된 상태)
            print(1)
        else:
            print(0)
```
